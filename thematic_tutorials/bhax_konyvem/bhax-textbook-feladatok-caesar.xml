<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <programlisting language="c"><![CDATA[#include <stdio.h>
#include <stdlib.h>

int main(){

int nr = 5;
double**tm;

	if ((tm = (double**) malloc (nr*sizeof (double*))) == NULL)
	{
		return -1;
	}
	for (int i = 0; i < nr; ++i)
	{
		if ((tm[i] = (double*) malloc ((i + 1)*sizeof (double))) == NULL)
		{
		return -1;
		}
	}
	
	for (int i = 0; i < nr; ++i)
		for (int j = 0; j < i + 1; ++j)
			tm[i][j] = i*(i + 1) / 2 + j;
	for (int i = 0; i < nr; ++i)
	{
		for (int j = 0; j < i + 1; ++j)
			printf ("%f, ", tm[i][j]);
		printf ("\n");
	}

	tm[3][0] = 42.0;
	(*(tm + 3))[1] = 43.0; 
	*(tm[3] + 2) = 44.0;
	*(*(tm + 3) + 3) = 45.0;
	for (int i = 0; i < nr; ++i)
	{
		for (int j = 0; j < i + 1; ++j)
			printf ("%f, ", tm[i][j]);
		printf ("\n");
	}
	for (int i = 0; i < nr; ++i)
		free (tm[i]);

	free (tm);
return 0;
}]]></programlisting>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <para>
Hogy miképpen történik az alsó háromszög mátrix tárolása? A magyarázat az, hogy a mátrix felsőhárom-
szög mátrixa 0-val lesz tele, emiatt ezt nem szükséges eltárolnunk (ezért is hívjuk helytakarékosnak), csak a fontos adatot, vagyis az alsó részt.
Miután a malloc sikeresen lefutott, az jóesetben visszaadja az adatra mutató pointer-t. Amennyiben a futtatása nem sikerül, egy null pointert kapunk vissza.
A lefoglalt terület nagyságát malloc paramétereként kell megadni.
(legelső esetben nr* sizeof(double *), nr = 5 esetén 40 bájt). ???még nem fix???
        </para>            
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
	<para>
	Itt látható a C nyelvben íródott titkosítóprogram.
	 <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 245

int main(int argc, char **argv){

char kulcs[MAX_KULCS];
char buffer[BUFFER_MERET];

int kulcs_index = 0;
int olvasott_bajtok = 0;

int kulcs_meret = strlen (argv[1]);
strncpy (kulcs, argv[1], MAX_KULCS);

while ((olvasott_bajtok = read (0, (void * ) buffer, BUFFER_MERET)))
	{
		for(int i=0; i<olvasott_bajtok; ++i)
		{
		buffer[i] = buffer [i] ^ kulcs[kulcs_index];
		kulcs_index = (kulcs_index + 1) % kulcs_meret;
		}
	
	write (1, buffer, olvasott_bajtok);
	}

}
}]]></programlisting>
	</para>
        <para>
    	A titkosító programunk mellé szükségünk lesz, egy sima szöveges állományra is amibe egy általunk kiválasztott szöveget másolhatunk. Ezt fogjuk később titkosítani, majd feloldani. Nevezzük el ezt a fájlt tiszta.szoveg -nek. Én a BIblia I. fejezetéből választottam. Ha megvan a titkosítattni kívánt szöveg, kezdjük is meg a szemléltetését. Elsőnek is fordítsuk le a programunkat a következőképpen:
 <programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ gcc e.c -o e -std=c99
]]></programlisting>
	Ezután a már megírt titkosítóba bevisszük a tiszta szövegünket majd az így keletkezett "bináris szemetet" a titkos.szoveg fájlba tároljuk el. Így ni:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ ./e kercerece <tiszta.szoveg >titkos.szoveg
]]></programlisting>
	Ezt ha nem baj most nem reprezentálnám, hogy mi lesz belőle ugyanis csupa krikszkraszokból fog állni a terminál ha végigpörgetjük. Akit azonban mégis érdekelne a sajátja, vagy csak letesztelné hogy működik-e, az az alábbi paranccsal.
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ more titkos.szoveg
ZERCE9
...
]]></programlisting>
	Mindez azonban fordítva is működik, azaz a mások által ugyan ezzel a programmal lefordított szövegeket tudjuk dekódolni is. Mondanám, hogy aki nem hiszi járjon utána de ez esetben mi is így teszünk. Nem nehéz kitalálni az eddigiek alapján, hogy hogyan is kell visszafejteni de a biztonság kedvéért bemutatom:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ ./e kercerece <titkos.szoveg
1    Kezdetben vala az Íge, és az Íge vala az Istennél, és Isten vala az Íge.
2    Ez kezdetben az Istennél vala.
...
]]></programlisting>

        </para>
	<para>
	Ez eddigiek során számomra talán ez volt az egyik legizgalmasabb és leglátványosabb feladat. Alapból mindig is érdekelt a számítástechnikának ez az ágazata. Nagyon elcsépelt szöveg de valóban általános iskolás korom óta etikus hacker szeretnék lenni. Még akkor is ha mindez nagyon távol áll ettől az álomtól, akkor is talán mondhatni, ez egy amolyan kis "bevezető" lehet ebbe a világba. Így hát nem mondok el nagy titkot ha azt állítom, hogy (személy szerint) ez volt az eddigi legjobb feladat. Természetesen a kódsorozat gyorsan és könnyen elkészíthetősége miatt is tetszett de ez már csak hab a tortán.
	</para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
           Az előző programunkból kiindulva , megírjuk a java féle titkosítónkat is, ezúttal azonban az eddigiektől eltérően, Java-t fogunk használni.
        </para>
	<para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>       
	<para>
<programlisting language="java"><![CDATA[
public class NullaEgyDump {
    public NullaEgyDump() {
                
        try {
            
            byte [] buffer = new byte[1];
            
            while(System.in.read(buffer) != -1) {
                
                for(int i=0; i<8; ++i) {

                    int egye = buffer[0] & 0x00000080;
                    
                    if((egye>>>7) == 1)
                        System.out.print(1);
                    else
                        System.out.print(0);

                    buffer[0] <<= 1;
                }
            }
            
        } catch(java.io.IOException e) {
            
            System.out.println("Hiba az olvasáskor, kilépek. " + e);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        new NullaEgyDump();
        
    }
    
}
]]></programlisting>
	Remélem ezúttal senki sem fog megharagudni illetve pánikba esik ha azt mondom, hogy nem fogok minden parancsot külön-külön elmagyarázni, hogy mit is csinál, ugyanis minden megegyezik a C programéval. Ettől függetlenül természetesen bemutatom, hogy mit is kell a terminálba ügyeskednünk.
 <programlisting><![CDATA[ 
hp@b3r3s:~/Dokumentumok/prog1$ javac ExorTitkosító.java
hp@b3r3s:~/Dokumentumok/prog1$ java ExorTitkosító erdeti > kodolt.szöveg
Malmö Svédország harmadik legnépesebb városa. 
hp@b3r3s:~/Dokumentumok/prog1$ more kodolt.szöveg
...valami olvashatatlan...
hp@b3r3s:~/Dokumentumok/prog1$ java ExorTitkosító eredeti < kodolt.szöveg
Malmö Svédország harmadik legnépesebb városa. 
]]></programlisting>
	</para>
             
    </section>        
    <section xml:id="bhax-textbook-feladatok-caesar.EXOR-toro">
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
A program írásánál arra kell figyelnünk, pontosabban az mindennek az alapja, hogy tudnunk kell a kulcs hosszát illetve annak az 'X' hosszúságú kulcs elemeit.
Emellet tudjuk a nyelvét is erre azonban csak a szöveg gyorsabb és egyszerűbb megtalalása miatt van szükség.
Ezt úgy döntjük el, hogy a "feltört" szövegnél megnézzük, hogy tartalmazza-e a leg-
gyakoribb magyar szavakat (pl.: hogy, nem, az, ha) és ha igen, akkor csak ezeket a szövegeket írjuk ki az
output-ra.
Az én esetemben a kulcs 6 karakter hosszúságúra sikeredett és nagyon kreatív módon a [s, b, e, r, e, m] karaktereket kapta. Gondolom senkinek sem jelent nagyobb fejtörést, hogy honnan jöttek ezek a betűk.
</para>
<para>
A programunkba lényegében vektort hozhatunk létre, amiben tárolni fogjuk a használatos karaktereket. A léptetéssel nekünk nem kell bajlódni, arra ott lesz a for ciklusunk, a kulcs hossz pedig azt adja meg, hogy hány helyen kell
léptetnünk az adott karaktereket, vagyis a for ciklusok számát adja meg.
A törés nagyon hasonlít az előző feladatokban tárgyalt és bemutatott titkosító algoritmusainkra, annyi különbséggel, hogy most nem adunk meg argumentumokat. Mivel ismerjük a kulcsot (hiszen mi adjuk meg), így könnyen visszakapjuk az eredeti szöveget is.
        </para>     
	<para>
Illetve bemutatom előtte a program fordítását, futtatását.
</para>
<para>
 <programlisting><![CDATA[ 
hp@b3r3s:~/Dokumentumok/bhax/prog1$  gcc toro_c.c -o toro_c -O3
hp@b3r3s:~/Dokumentumok/bhax/prog1$  ./brute_c < titkos.szoveg
]]></programlisting>
</para>
<para>
Ha a kulcsunk és a tiszta szöveg megjelenik, akkor sikerrel jártunk.
<programlisting><![CDATA[ 
Kulcs: [beresm]
Tiszta szoveg: Kezdetben vala az Íge, és az Íge vala az Istennél, és Isten vala az Íge.
Ez kezdetben az Istennél vala.
Minden ő általa lett és nála nélkül semmi sem lett, ami lett...
]]></programlisting>
</para>
<para>
A programunk megértéséhez elegendő lesz ez a toro.c kódból származó 'kisebb' kódcsipet.
<programlisting language="c"><![CDATA[
  char letters[] = {'s','b','e','r','e','m'};
  int letterCount = sizeof(letters)/sizeof(letters[0]);

  for (int ii = 0; ii <= letterCount; ++ii)
    for (int ji = 0; ji <= letterCount; ++ji)
      for (int ki = 0; ki <= letterCount; ++ki)
	      for (int li = 0; li <= letterCount; ++li)
	        for (int mi = 0; mi <= letterCount; ++mi)
	          for (int ni = 0; ni <= letterCount; ++ni)
	            for (int oi = 0; oi <= letterCount; ++oi)
		          {
                kulcs[0] = letters[ii];
                kulcs[1] = letters[ji];
                kulcs[2] = letters[ki];
                kulcs[3] = letters[li];
                kulcs[4] = letters[mi];
                kulcs[5] = letters[ni];
                kulcs[6] = letters[oi];
                if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
                  printf("Kulcs: [%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",letters[ii], letters[ji], letters[ki], letters[li], letters[mi], letters[ni], letters[oi], titkos);


                exor (kulcs, KULCS_MERET, titkos, p - titkos);
              }
  return 0;
}
]]></programlisting>
	</para>       
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
	<para>
	Azoknak esetleg akiknek újdonság lenne a neurális hálózat mint fogalom, itt egy gyorstalapló a <link xlink:href="https://regi.tankonyvtar.hu/hu/tartalom/tamop425/0026_neuralis_4_4/ch01.html">tankonyvtar</link> oldaláról:
Neurális hálózatnak nevezzük azt a hardver vagy szoftver megvalósítású párhuzamos, elosztott működésre képes információfeldolgozó eszközt, amely:
</para>
<para>

    -azonos, vagy hasonló típusú – általában nagyszámú – lokális feldolgozást végző műveleti elem, neuron (processing element, neuron) többnyire rendezett topológiájú, nagymértékben összekapcsolt rendszeréből áll,
</para>
<para>

    -rendelkezik tanulási algoritmussal (learning algorithm), mely általában minta alapján való tanulást jelent, és amely az információfeldolgozás módját határozza meg,
</para>
<para>

    -rendelkezik a megtanult információ felhasználását lehetővé tevő információ előhívási, vagy röviden előhívási algoritmussal (recall algorithm).
	</para>
	<para>
	<programlisting><![CDATA[
	library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])


a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])	
	]]></programlisting>
	</para>
        <para>
          A fenti programban a neuralnet libraryt használjuk. A program első részében az OR logikai műveletet mutatjuk be és taníttatjuk meg a programunkkal. Az OR művelet eredménye 1, ha a két tag közül legalább az egyik 1-es. Ezt a szabályt adjuk meg neki a program elején az ’a1’, ’a2’ és ’OR’ segítségével.
A program többi részében is ezt láthatjuk az EXOR-ral és az AND-del. A program a szabályok megadásával
megtanulja, hogy az EXOR ( különböző bitek -> 1, azonos bitek -> 0 ) és az AND ( különböző vagy 0 bitekUniverzális programozás
-> 0, két 1-es bit -> 1 ) hogyan működik.

        </para> 
	<figure>
            <title>Gráf alapú modell</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/neural.png" scale="40" />
                </imageobject>
                <textobject>
                    <phrase>Gráf alapú modell</phrase>
                </textobject>
            </mediaobject>
        </figure>
           
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
<programlisting language="c"><![CDATA[
#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>
int main ( int argc, char **argv){
png::image <png::rgb_pixel> png_image (argv[1]);
int size = png_image.get_width()*png_image.get_height();
Perceptron* p = new Perceptron (3, size, 256, 1);
double* image = new double[size];
for ( int i {0}; i < png_image.get_width(); ++i)
for ( int j {0}; j < png_image.get_height(); ++j)
image[i*png_image.get_width() +j] = png_image[i][j].red;
double value = (*p)(image);
std::cout<< value <<std::endl;
delete p;
delete [] image;
FT
}
]]></programlisting>
<figure>
            <title>Gráf alapú modell</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/mandel.png" scale="40" />
                </imageobject>
                <textobject>
                    <phrase>Gráf alapú modell</phrase>
                </textobject>
            </mediaobject>
        </figure>
        </para>  
	<para>
A teszteléshez a ql.hpp-ben található Perceptron osztályt használjuk. Ezzel a programmal a mandelbrot
halmaznak a képét olvassuk be a neurális hálónk bemenetébe a következőképpen:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/bhax/prog1$ gcc main.cpp mlp.cpp -o percep -lpng
hp@b3r3s:~/Dokumentumok/bhax/prog1$ ./percep mandel.png
]]></programlisting>
Egy neurális háló 3 rétegből áll. Az első réteg
a bemeneti réteg, ennek a rétegnek a mérete a kép szélessége * kép magassága. A második réteg a rejtett
réteg, itt alakítjuk át a bemeneten kapott információt, itt számolások történnek, a fenti kódban ez a két for
ciklussal történik. A harmadik réteg a kimeneti réteg, itt a kapott eredményt iratjuk ki.
	</para>          
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
