<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
 	</para>
	<para>
	Illetve a saját (védési) videó <link xlink:href="https://www.youtube.com/watch?v=8HSc1-dwNic">https://www.youtube.com/watch?v=8HSc1-dwNic</link>
       	</para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <stdlib.h>

int main(){

int nr = 5;
double**tm;

	printf("%p\n", &tm);	
	
	if ((tm = (double**) malloc (nr*sizeof (double*))) == NULL)
	{
		return -1;
	}

	printf("%p\n", tm);	

	for (int i = 0; i < nr; ++i)
	{
		if ((tm[i] = (double*) malloc ((i + 1)*sizeof (double))) == NULL)
		{
		return -1;
		}
	}


	printf("%p\n", tm[0]);	

	
	for (int i = 0; i < nr; ++i)
		for (int j = 0; j < i + 1; ++j)
			tm[i][j] = i*(i + 1) / 2 + j;

	for (int i = 0; i < nr; ++i)
	{
		for (int j = 0; j < i + 1; ++j)
			printf ("%f, ", tm[i][j]);
		printf ("\n");
	}

	tm[3][0] = 42.0;
	(*(tm + 3))[1] = 43.0; 
	*(tm[3] + 2) = 44.0;
	*(*(tm + 3) + 3) = 45.0;

	for (int i = 0; i < nr; ++i)
	{
		for (int j = 0; j < i + 1; ++j)
			printf ("%f, ", tm[i][j]);
		printf ("\n");
	}
	for (int i = 0; i < nr; ++i)
		free (tm[i]);

	free (tm);
return 0;
}]]></programlisting>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <para>
Hogy miképpen történik az alsó háromszög mátrix tárolása? A magyarázat az, hogy a mátrix felsőhárom-
szög mátrixa 0-val lesz tele, emiatt ezt nem szükséges eltárolnunk (ezért is hívjuk helytakarékosnak), csak a fontos adatot, vagyis az alsó részt.
Miután a malloc sikeresen lefutott, az jóesetben visszaadja az adatra mutató pointer-t. Amennyiben a futtatása nem sikerül, egy null pointert kapunk vissza.
A lefoglalt terület nagyságát malloc paramétereként kell megadni.
(legelső esetben nr* sizeof(double *), nr = 5 esetén 40 bájt). ???még nem fix???
        </para>            
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/02/15/felvetelt_hirdet_a_cia">Felvételt hirdet a CIA</link>       
        </para>
	<para>
	Itt látható a C nyelvben íródott titkosítóprogram.
	 <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 245

int main(int argc, char **argv){

char kulcs[MAX_KULCS];
char buffer[BUFFER_MERET];

int kulcs_index = 0;
int olvasott_bajtok = 0;

int kulcs_meret = strlen (argv[1]);
strncpy (kulcs, argv[1], MAX_KULCS);

while ((olvasott_bajtok = read (0, (void * ) buffer, BUFFER_MERET)))
	{
		for(int i=0; i<olvasott_bajtok; ++i)
		{
		buffer[i] = buffer [i] ^ kulcs[kulcs_index];
		kulcs_index = (kulcs_index + 1) % kulcs_meret;
		}
	
	write (1, buffer, olvasott_bajtok);
	}

}
}]]></programlisting>
	</para>
        <para>
    	A titkosító programunk mellé szükségünk lesz, egy sima szöveges állományra is amibe egy általunk kiválasztott szöveget másolhatunk. Ezt fogjuk később titkosítani, majd feloldani. Nevezzük el ezt a fájlt tiszta.szoveg -nek. Én a BIblia I. fejezetéből választottam. Ha megvan a titkosítattni kívánt szöveg, kezdjük is meg a szemléltetését. Elsőnek is fordítsuk le a programunkat a következőképpen:
 <programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ gcc e.c -o e -std=c99
]]></programlisting>
	Ezután a már megírt titkosítóba bevisszük a tiszta szövegünket majd az így keletkezett "bináris szemetet" a titkos.szoveg fájlba tároljuk el. Így ni:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ ./e kercerece <tiszta.szoveg >titkos.szoveg
]]></programlisting>
	Ezt ha nem baj most nem reprezentálnám, hogy mi lesz belőle ugyanis csupa krikszkraszokból fog állni a terminál ha végigpörgetjük. Akit azonban mégis érdekelne a sajátja, vagy csak letesztelné hogy működik-e, az az alábbi paranccsal.
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ more titkos.szoveg
ZERCE9
...
]]></programlisting>
	Mindez azonban fordítva is működik, azaz a mások által ugyan ezzel a programmal lefordított szövegeket tudjuk dekódolni is. Mondanám, hogy aki nem hiszi járjon utána de ez esetben mi is így teszünk. Nem nehéz kitalálni az eddigiek alapján, hogy hogyan is kell visszafejteni de a biztonság kedvéért bemutatom:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/prog1$ ./e kercerece <titkos.szoveg
1    Kezdetben vala az Íge, és az Íge vala az Istennél, és Isten vala az Íge.
2    Ez kezdetben az Istennél vala.
...
]]></programlisting>

        </para>
	<para>
	Ez eddigiek során számomra talán ez volt az egyik legizgalmasabb és leglátványosabb feladat. Alapból mindig is érdekelt a számítástechnikának ez az ágazata. Nagyon elcsépelt szöveg de valóban általános iskolás korom óta etikus hacker szeretnék lenni. Még akkor is ha mindez nagyon távol áll ettől az álomtól, akkor is talán mondhatni, ez egy amolyan kis "bevezető" lehet ebbe a világba. Így hát nem mondok el nagy titkot ha azt állítom, hogy (személy szerint) ez volt az eddigi legjobb feladat. Természetesen a kódsorozat gyorsan és könnyen elkészíthetősége miatt is tetszett de ez már csak hab a tortán.
	</para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
           Az előző programunkból kiindulva , megírjuk a java féle titkosítónkat is, ezúttal azonban az eddigiektől eltérően, Java-t fogunk használni.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>     
	<para>
<programlisting language="java"><![CDATA[
public class ExorTitkosító {
    
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();		//Adjunk értéket a kulcsunknak	
        byte [] buffer = new byte[256];			//Megkreáljuk a buffert
        int kulcsIndex = 0;	
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]); //XOR művelet végrehajtása a buffer és a kulcs között, vagyis titkosítunk.
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}
]]></programlisting>
	Remélem ezúttal senki sem fog megharagudni illetve pánikba esik ha azt mondom, hogy nem fogok minden parancsot külön-külön elmagyarázni, hogy mit is csinál, ugyanis minden megegyezik a C programéval. Ettől függetlenül természetesen bemutatom, hogy mit is kell a terminálba ügyeskednünk.
 <programlisting><![CDATA[ 
hp@b3r3s:~/Dokumentumok/prog1$ javac ExorTitkosító.java
hp@b3r3s:~/Dokumentumok/prog1$ java ExorTitkosító erdeti > kodolt.szöveg
Malmö Svédország harmadik legnépesebb városa. 
hp@b3r3s:~/Dokumentumok/prog1$ more kodolt.szöveg
...valami olvashatatlan...
hp@b3r3s:~/Dokumentumok/prog1$ java ExorTitkosító eredeti < kodolt.szöveg
Malmö Svédország harmadik legnépesebb városa. 
]]></programlisting>
	</para>
             
    </section>        
    <section xml:id="bhax-textbook-feladatok-caesar.EXOR-toro">
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/02/15/felvetelt_hirdet_a_cia">Programozó Páternoszter</link> illetve a t.c fájl.
        </para>   

<para>
<programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
  int sz = 0;
  for (int i = 0; i < titkos_meret; ++i)
    if (titkos[i] == ' ')
      ++sz;

  return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{

	// A tiszta szöveg feltehetően tartalmazza a gyakori magyar szavakat illetve az átlagos szóhossz vizsgálatával csökkentjük a potenciális töréseket.
  double szohossz = atlagos_szohossz (titkos, titkos_meret);

  return szohossz > 6.0 && szohossz < 9.0
    && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
    && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

  int kulcs_index = 0;

  for (int i = 0; i < titkos_meret; ++i)
    {

      titkos[i] = titkos[i] ^ kulcs[kulcs_index];
      kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

  exor (kulcs, kulcs_meret, titkos, titkos_meret);

  return tiszta_lehet (titkos, titkos_meret);

}

int
main (void)
{

  char kulcs[KULCS_MERET];
  char titkos[MAX_TITKOS];
  char *p = titkos;
  int olvasott_bajtok;

  // titkos bájt berántása
  while ((olvasott_bajtok =
	  read (0, (void *) p,
		(p - titkos + OLVASAS_BUFFER < MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
    p += olvasott_bajtok;

  // maradék hely nullázása a titkos bufferben  
  for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
    titkos[p - titkos + i] = '\0';

  // összes kulcs előállítása
  for (int ii = '0'; ii <= '9'; ++ii)
    for (int ji = '0'; ji <= '9'; ++ji)
      for (int ki = '0'; ki <= '9'; ++ki)
	for (int li = '0'; li <= '9'; ++li)
	  for (int mi = '0'; mi <= '9'; ++mi)
	    for (int ni = '0'; ni <= '9'; ++ni)
	      for (int oi = '0'; oi <= '9'; ++oi)
		for (int pi = '0'; pi <= '9'; ++pi)
		  {
		    kulcs[0] = ii;
		    kulcs[1] = ji;
		    kulcs[2] = ki;
		    kulcs[3] = li;
		    kulcs[4] = mi;
		    kulcs[5] = ni;
		    kulcs[6] = oi;
		    kulcs[7] = pi;

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi, ni, oi, pi, titkos);

		    // újra EXOR-ozunk, igy nem kell egy második buffer  
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }

  return 0;
}
]]></programlisting>
	</para>  
<para>
A program fordítása és futtatása előtt győződjünk meg róla, hogy elkészült a titkos szövegünk.
</para>
<para>
 <programlisting><![CDATA[ 
hp@b3r3s:~/Dokumentumok/bhax/prog1$  ./e kercerece <tiszta.szoveg > titkos.szoveg
]]></programlisting>
</para>
<para>
Ezután jöhet a jól megszokott parancs páros amivel ha minden igaz vissza tudjuk fejteni a lekódolt szöveget.
<programlisting><![CDATA[ 
hp@b3r3s:~/Dokumentumok/bhax/prog1$  gcc t.c -o t
hp@b3r3s:~/Dokumentumok/bhax/prog1$  ./t < titkos.szoveg
]]></programlisting>
</para>     
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
	<para>
	Azoknak esetleg akiknek újdonság lenne a neurális hálózat mint fogalom, itt egy gyorstalapló a <link xlink:href="https://regi.tankonyvtar.hu/hu/tartalom/tamop425/0026_neuralis_4_4/ch01.html">tankonyvtar</link> oldaláról:
Neurális hálózatnak nevezzük azt a hardver vagy szoftver megvalósítású párhuzamos, elosztott működésre képes információfeldolgozó eszközt, amely:
</para>
<para>

    -azonos, vagy hasonló típusú – általában nagyszámú – lokális feldolgozást végző műveleti elem, neuron (processing element, neuron) többnyire rendezett topológiájú, nagymértékben összekapcsolt rendszeréből áll,
</para>
<para>

    -rendelkezik tanulási algoritmussal (learning algorithm), mely általában minta alapján való tanulást jelent, és amely az információfeldolgozás módját határozza meg,
</para>
<para>

    -rendelkezik a megtanult információ felhasználását lehetővé tevő információ előhívási, vagy röviden előhívási algoritmussal (recall algorithm).
	</para>
	<para>
	<programlisting><![CDATA[
	library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])


a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])	
	]]></programlisting>
	</para>
        <para>
          A fenti programban a neuralnet libraryt használjuk. A program első részében az OR logikai műveletet mutatjuk be és taníttatjuk meg a programunkkal. Az OR művelet eredménye 1, ha a két tag közül legalább az egyik 1-es. Ezt a szabályt adjuk meg neki a program elején az ’a1’, ’a2’ és ’OR’ segítségével.
A program többi részében is ezt láthatjuk az EXOR-ral és az AND-del. A program a szabályok megadásával
megtanulja, hogy az EXOR ( különböző bitek -> 1, azonos bitek -> 0 ) és az AND ( különböző vagy 0 bitekUniverzális programozás
-> 0, két 1-es bit -> 1 ) hogyan működik.

        </para> 
	<figure>
            <title>Gráf alapú modell</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/neural.png" scale="40" />
                </imageobject>
                <textobject>
                    <phrase>Gráf alapú modell</phrase>
                </textobject>
            </mediaobject>
        </figure>
           
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
<programlisting language="c"><![CDATA[
#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>
int main ( int argc, char **argv){
png::image <png::rgb_pixel> png_image (argv[1]);
int size = png_image.get_width()*png_image.get_height();
Perceptron* p = new Perceptron (3, size, 256, 1);
double* image = new double[size];
for ( int i {0}; i < png_image.get_width(); ++i)
for ( int j {0}; j < png_image.get_height(); ++j)
image[i*png_image.get_width() +j] = png_image[i][j].red;
double value = (*p)(image);
std::cout<< value <<std::endl;
delete p;
delete [] image;
FT
}
]]></programlisting>
<figure>
            <title>Gráf alapú modell</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/mandel.png" scale="40" />
                </imageobject>
                <textobject>
                    <phrase>Gráf alapú modell</phrase>
                </textobject>
            </mediaobject>
        </figure>
        </para>  
	<para>
A teszteléshez a ql.hpp-ben található Perceptron osztályt használjuk. Ezzel a programmal a mandelbrot
halmaznak a képét olvassuk be a neurális hálónk bemenetébe a következőképpen:
<programlisting><![CDATA[
hp@b3r3s:~/Dokumentumok/bhax/prog1$ gcc main.cpp mlp.cpp -o percep -lpng
hp@b3r3s:~/Dokumentumok/bhax/prog1$ ./percep mandel.png
]]></programlisting>
Egy neurális háló 3 rétegből áll. Az első réteg
a bemeneti réteg, ennek a rétegnek a mérete a kép szélessége * kép magassága. A második réteg a rejtett
réteg, itt alakítjuk át a bemeneten kapott információt, itt számolások történnek, a fenti kódban ez a két for
ciklussal történik. A harmadik réteg a kimeneti réteg, itt a kapott eredményt iratjuk ki.
	</para>          
    </section>        
        <section>
        <title>Vörös Pipacs Pokol/ írd ki mit lát Steve</title>
        <para>  
Mivel a Chomsky-féle programunk már egyébként tartalmazta ezt a tulajdonságot is, így elég ha csak azt az aprócska kódcsipetet ide bemásolom.
<programlisting language="c"><![CDATA[
while world_state.is_mission_running:
            if world_state.number_of_observations_since_last_state != 0:
                sensations = world_state.observations[-1].text
                observations = json.loads(sensations)
                nbr3x3x3 = observations.get("nbr3x3", 0)

                if "LineOfSight" in observations :
                    lineOfSight = observations["LineOfSight"]
                    self.lookingat = lineOfSight["type"]
                    print("\(    O__O )/: ", self.lookingat)
]]></programlisting>
Ez lényegében annyit jelent, hogy ameddig a programunk fut, a terminálba folyamatosan látni fogjuk amire éppen Steve néz.
<figure>
            <title>Lássuk, mit lát Steve</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/pipacs.png" scale="30" />
                </imageobject>
                <textobject>
                    <phrase>Gráf alapú modell</phrase>
                </textobject>
            </mediaobject>
        </figure>
	</para>  
</section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
